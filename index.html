<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carpe Diem – Stock Simulator</title>
  <style>
    :root{
      --bg:#0b132b;
      --panel:#14213d;
      --card:#1b294a;
      --accent:#4cafef;
      --accent-2:#357abd;
      --text:#ffffff;
      --muted:#eef4ff;
      --muted-2:#d7e3ff;
      --good:#3ddc97;
      --bad:#ff6b6b;
      --border:#ffffff33;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
      background:var(--bg); color:var(--text);
    }
    header{
      background:linear-gradient(90deg,#0e1a34,#18335f);
      padding:14px 16px; text-align:center; font-weight:800; letter-spacing:.3px;
      box-shadow:0 2px 14px #0008;
    }
    .wrap{max-width:1160px;margin:24px auto;padding:0 16px}
    .hidden{display:none !important}
    .panel{
      background:var(--panel); border:1px solid var(--border); border-radius:16px; box-shadow:0 6px 24px #0006;
    }
    .card{
      background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:0 4px 18px #0005;
    }
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:10px 14px; border-radius:10px; border:1px solid transparent;
      font-weight:700; cursor:pointer; transition:.18s ease;
    }
    .btn-primary{ background:var(--accent); color:#041426 }
    .btn-primary:hover{ background:var(--accent-2) }
    .btn-ghost{ background:transparent; border-color:var(--border); color:var(--text) }
    .btn-ghost:hover{ background:#ffffff14 }
    /* Login */
    .login-shell{ min-height:70vh; display:grid; place-items:center; }
    .login-box{ width:min(480px,100%); padding:28px }
    .input{
      width:100%; padding:12px 14px; border-radius:10px; border:1px solid var(--border); background:#0e1a34; color:#fff;
    }
    .input::placeholder{ color:#f0f5ff }
    label{ font-size:.9rem; color:var(--muted); margin-bottom:6px; display:inline-block }
    /* Grid */
    .grid{ display:grid; gap:16px }
    .grid-3{ grid-template-columns:repeat(3,1fr) }
    @media (max-width:960px){ .grid-3{ grid-template-columns:repeat(2,1fr) } }
    @media (max-width:640px){ .grid-3{ grid-template-columns:1fr } }
    /* Stock tiles */
    .tile{
      padding:12px; border-radius:12px; border:1px solid var(--border); background:#0f1c37;
      cursor:pointer; transition:transform .12s ease, border-color .12s ease;
    }
    .tile:hover{ transform:translateY(-1px); border-color:#ffffff55 }
    .tile .name{ font-weight:800; color:#fff }
    .tile .price{ color:#fff; margin-top:2px; font-weight:800 }
    /* Metrics row */
    .metrics{ display:grid; grid-template-columns:repeat(3,1fr); gap:14px }
    @media (max-width:700px){ .metrics{ grid-template-columns:1fr } }
    .metric{
      padding:14px; border-radius:12px; border:1px solid var(--border); background:#0f1c37; text-align:center;
    }
    .metric .label{ font-size:.85rem; color:var(--muted-2); letter-spacing:.02em }
    .metric .value{ font-size:1.6rem; font-weight:800; margin-top:6px; color:#fff }
    /* Details */
    .details{ display:grid; grid-template-columns:2fr 1fr; gap:16px }
    @media (max-width:900px){ .details{ grid-template-columns:1fr } }
    canvas{ width:100%; height:220px; background:#0b1730; border:1px solid var(--border); border-radius:12px }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .spacer{ flex:1 }
    .muted{ color:var(--muted) }
    hr.sep{ border:none; height:1px; background:var(--border); margin:10px 0 }
    table{ width:100%; border-collapse:separate; border-spacing:0 8px }
    th,td{ text-align:left; padding:8px 10px; color:#fff }
    th{ color:#e9f1ff; font-weight:800; border-bottom:1px solid var(--border) }
    tr.data{ background:#0f1c37; border:1px solid var(--border) }
    tr.data td{ border-top:1px solid var(--border); border-bottom:1px solid var(--border) }
    small.err{ color:#ffd0d0 }
  </style>
</head>
<body>
  <header>Carpe Diem – Stock Simulator</header>

  <main class="wrap">
    <!-- LOGIN -->
    <section id="loginSection" class="panel login-shell">
      <form id="loginForm" class="login-box card" autocomplete="on" novalidate>
        <h2 style="margin:0 0 14px 0">Sign in</h2>
        <div class="grid">
          <div>
            <label for="email">Email</label>
            <input id="email" type="email" class="input" placeholder="name@gsis.ac.in" required />
          </div>
          <div>
            <label for="password">Password</label>
            <input id="password" type="password" class="input" placeholder="••••••••" required />
          </div>
          <div class="row" style="margin-top:4px">
            <button id="loginBtn" class="btn btn-primary" type="submit">Log in</button>
            <span id="loginError" class="muted" style="margin-left:8px"></span>
          </div>
        </div>
      </form>
    </section>

    <!-- DASHBOARD -->
    <section id="dashboard" class="hidden">
      <div class="panel" style="padding:12px 14px; display:flex; align-items:center; gap:10px; flex-wrap:wrap">
        <strong id="roleHeader">Welcome</strong>
        <span class="spacer"></span>
        <button id="logoutBtn" class="btn btn-ghost">Log out</button>
      </div>

      <!-- Trader metrics (NEVER shown to admins) -->
      <div id="traderMetrics" class="metrics hidden" style="margin:16px 0">
        <div class="metric">
          <div class="label">Working Capital</div>
          <div class="value">₹<span id="workingCap">0.00</span></div>
        </div>
        <div class="metric">
          <div class="label">Invested Capital</div>
          <div class="value">₹<span id="investedCap">0.00</span></div>
        </div>
        <div class="metric">
          <div class="label">Profit / Loss</div>
          <div class="value" id="profitLoss">0.00%</div>
        </div>
      </div>

      <!-- Stocks -->
      <div class="panel" style="padding:16px">
        <div class="row" style="margin-bottom:10px">
          <h3 style="margin:0">Stocks</h3>
          <span class="spacer"></span>
        </div>
        <div id="stockList" class="grid grid-3"></div>
      </div>

      <!-- Details + Admin/Trader column -->
      <section class="details" style="margin-top:16px">
        <!-- LEFT: Trader = chart+trade; Admin = portfolio viewer -->
        <div class="panel" style="padding:16px">
          <div class="row">
            <h3 id="detailName" style="margin:0">Select a stock</h3>
            <span class="spacer"></span>
            <div id="detailPrice" class="muted"></div>
          </div>

          <!-- Trader chart -->
          <canvas id="chart" width="900" height="220"></canvas>

          <!-- Trader trade bar -->
          <div id="tradeBar" class="row" style="margin-top:10px">
            <label for="qty" class="muted">Qty</label>
            <input id="qty" class="input" type="number" min="1" value="1" style="width:120px" />
            <button id="buyBtn" class="btn btn-primary">Buy</button>
            <button id="sellBtn" class="btn btn-ghost">Sell</button>
            <span id="tradeMsg" class="muted"></span>
          </div>
          <div id="autoRow" class="row" style="margin-top:10px">
            <label for="autoPrice" class="muted">Auto-sell at price</label>
            <input id="autoPrice" class="input" type="number" min="0" placeholder="e.g. 1200" style="width:160px" />
            <input id="autoQty" class="input" type="number" min="1" placeholder="qty" style="width:120px" />
            <button id="setAutoBtn" class="btn btn-primary">Set Auto-Sell</button>
            <button id="clearAutoBtn" class="btn btn-ghost">Clear</button>
            <span id="autoMsg" class="muted"></span>
          </div>

          <!-- Admin-only portfolio view placed here -->
          <div id="adminPortfolioView" class="hidden">
            <h3 style="margin:14px 0 8px 0">View Trader Portfolio</h3>
            <div class="row" style="margin-bottom:8px">
              <select id="traderSelect" class="input" style="max-width:420px;"></select>
            </div>
            <div id="portfolioWrap" class="card" style="padding:10px; display:none">
              <h4 id="pfTitle" style="margin:6px 0">Portfolio</h4>
              <div class="row muted" id="pfSummary"></div>
              <table style="margin-top:6px">
                <thead><tr><th>Stock</th><th>Qty</th><th>Price</th><th>Value</th></tr></thead>
                <tbody id="pfTable"></tbody>
              </table>

              <!-- NEW: trade history for selected trader -->
              <h4 style="margin:12px 0 6px 0">Trade History</h4>
              <div id="historyWrap" class="card" style="padding:8px; max-height:240px; overflow:auto">
                <table>
                  <thead>
                    <tr><th>Time</th><th>Action</th><th>Stock</th><th>Qty</th><th>Price</th><th>Value</th></tr>
                  </thead>
                  <tbody id="historyTable"></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- RIGHT: Admin controls OR Trader portfolio -->
        <div class="panel" style="padding:16px">
          <!-- Trader side panel (visible only to traders) -->
          <div id="traderSide" class="hidden">
            <h3 style="margin-top:0">My Portfolio</h3>
            <div class="card" style="padding:10px; max-height:260px; overflow:auto">
              <div id="traderPfSummary" class="row muted" style="margin-bottom:6px"></div>
              <table>
                <thead><tr><th>Stock</th><th>Qty</th><th>Price</th><th>Value</th></tr></thead>
                <tbody id="traderPfTable"></tbody>
              </table>
            </div>
          </div>

          <!-- Admin block -->
          <h3 style="margin-top:0">Admin</h3>
          <div id="adminOnlyHint" class="muted">Only visible for admins</div>

          <div id="adminControls" class="hidden">
            <div class="row" style="align-items:baseline">
              <label class="muted" style="margin-right:6px">Selected stock:</label>
              <strong id="adminSelected" style="font-weight:800">None</strong>
              <span class="muted" id="adminSelectedPrice" style="margin-left:6px"></span>
            </div>

            <div class="row" style="margin-top:8px">
              <label class="muted">Adjust selected stock</label>
            </div>
            <div class="row">
              <button id="raiseBtn" class="btn btn-primary">Increase 10%</button>
              <button id="lowerBtn" class="btn btn-ghost">Decrease 10%</button>
              <button id="raise50Btn" class="btn btn-primary">Increase 50%</button>
              <button id="lower50Btn" class="btn btn-ghost">Decrease 50%</button>
            </div>

            <hr class="sep" />
            <div class="row">
              <label class="muted">Set starting funds for ALL traders</label>
            </div>
            <div class="row">
              <input id="allFunds" class="input" type="number" min="0" placeholder="e.g. 100000" style="width:180px" />
              <button id="applyFundsBtn" class="btn btn-primary">Apply</button>
              <span id="fundsMsg" class="muted"></span>
            </div>

            <hr class="sep" />
            <button id="resetBtn" class="btn btn-ghost" style="border-color:#ffc107;color:#ffc107;width:100%">
              ⚠️ Hard RESET (All Traders + Stocks)
            </button>

            <!-- Freeze / Unfreeze controls -->
            <div class="row" style="margin-top:10px">
              <button id="freezeBtn" class="btn btn-ghost" style="border-color:#ff6b6b;color:#ff6b6b">Freeze Selected</button>
              <button id="unfreezeBtn" class="btn btn-primary">Unfreeze Selected</button>
              <span id="freezeMsg" class="muted"></span>
            </div>

            <hr class="sep" />
            <h4 style="margin:6px 0">Trader Rankings</h4>
            <div id="rankWrap" class="card" style="padding:10px; max-height:260px; overflow:auto">
              <table>
                <thead>
                  <tr><th>#</th><th>Trader</th><th>Total Equity</th><th>P/L</th></tr>
                </thead>
                <tbody id="rankTable"></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
    </section>
  </main>
<!-- APP (Firebase + logic) -->
  <script type="module">
    /***** Firebase *****/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
    import {
      getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged,
      setPersistence, browserSessionPersistence
    } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, collection, getDocs,
      onSnapshot, query, where, runTransaction
    } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";

    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyC72GZrrjG4UIR3qzDs-I2QWIgSFd4Yehs",
      authDomain: "carpediem-f6948.firebaseapp.com",
      projectId: "carpediem-f6948",
      storageBucket: "carpediem-f6948.firebasestorage.app",
      messagingSenderId: "705608113463",
      appId: "1:705608113463:web:eb70088734b33486c70eb2"
    };
    const APP_ID = "carpe_diem";
    const app = initializeApp(FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getFirestore(app);

    /* Session persistence (non-blocking) */
    (async () => {
      try { await setPersistence(auth, browserSessionPersistence); }
      catch(e){ console.warn("Auth persistence not set:", e?.message||e); }
    })();

    /***** Elements *****/
    const $ = (id)=>document.getElementById(id);
    const loginSection = $("loginSection");
    const loginForm    = $("loginForm");
    const loginBtn     = $("loginBtn");
    const loginError   = $("loginError");

    const dashboard    = $("dashboard");
    const roleHeader   = $("roleHeader");
    const logoutBtn    = $("logoutBtn");

    const traderMetrics = $("traderMetrics");
    const workingCapEl  = $("workingCap");
    const investedCapEl = $("investedCap");
    const profitLossEl  = $("profitLoss");

    const stockList = $("stockList");
    const detailName  = $("detailName");
    const detailPrice = $("detailPrice");
    const chartEl     = $("chart");
    const qtyEl       = $("qty");
    const tradeMsg    = $("tradeMsg");
    const tradeBar    = $("tradeBar");
    const adminPortfolioView = $("adminPortfolioView");

    const autoPrice   = $("autoPrice");
    const autoQty     = $("autoQty");
    const setAutoBtn  = $("setAutoBtn");
    const clearAutoBtn= $("clearAutoBtn");
    const autoMsg     = $("autoMsg");

    const adminOnlyHint = $("adminOnlyHint");
    const adminControls = $("adminControls");
    const raiseBtn      = $("raiseBtn");
    const lowerBtn      = $("lowerBtn");
    const raise50Btn    = $("raise50Btn");
    const lower50Btn    = $("lower50Btn");
    const allFunds      = $("allFunds");
    const applyFundsBtn = $("applyFundsBtn");
    const fundsMsg      = $("fundsMsg");
    const rankTable     = $("rankTable");
    const traderSelect  = $("traderSelect");
    const portfolioWrap = $("portfolioWrap");
    const pfTitle       = $("pfTitle");
    const pfSummary     = $("pfSummary");
    const pfTable       = $("pfTable");
    const adminSelected = $("adminSelected");
    const adminSelectedPrice = $("adminSelectedPrice");

    const freezeBtn   = $("freezeBtn");
    const unfreezeBtn = $("unfreezeBtn");
    const freezeMsg   = $("freezeMsg");

    const traderSide      = $("traderSide");
    const traderPfSummary = $("traderPfSummary");
    const traderPfTable   = $("traderPfTable");

    const buyBtn  = $("buyBtn");
    const sellBtn = $("sellBtn");

    // NEW: history table elements (admin view)
    const historyTable = $("historyTable");

    /***** State *****/
    let me = null, myRole = null;
    let selectedId = null;
    // id -> { id, name, baseline, price, defaultBaseline, frozen }
    let stocks = {};
    let myTrader = null;

    // chart state (bar graph)
    let series = [];
    let lastSampleTime = 0;

    // price step timer
    const TICK_MS = 3000;
    let lastProcessedTick = -1;  // price tick
    let lastAutosTick = -1;      // <-- separate gate for auto-sells (FIX)

    const SEED_STOCKS = [
      "Reliance Industries","TCS","Infosys","HDFC Bank","ICICI Bank",
      "SBI","Bharti Airtel","HCL Technologies","Asian Paints","Wipro",
      "Tata Motors","Adani Enterprises","Hindustan Unilever","Larsen & Toubro","Bajaj Finance",
      "Kotak Mahindra Bank","UltraTech Cement","NTPC","JSW Steel","Tech Mahindra",
      "Power Grid","Adani Ports","Axis Bank","Maruti Suzuki","Grasim Industries"
    ];

    /***** Pricing helpers (step every 3s) *****/
    function clamp(n){ return Math.max(1, Number.isFinite(n)? n : 0); }
    function fmt(n, currency = true){
      if(!Number.isFinite(n)) return "N/A";
      const options = currency ? { style: 'currency', currency: 'INR' } : { minimumFractionDigits: 2, maximumFractionDigits: 2 };
      return n.toLocaleString('en-IN', options);
    }

    function currentPriceFor(stock){
      if (!stock) return 0;
      if (Number.isFinite(stock.price)) return stock.price;
      const base = Number.isFinite(stock.baseline) ? stock.baseline : (stock.defaultBaseline||500);
      return base;
    }
    function jumpOnce(stock){
      const base = Number.isFinite(stock.baseline) ? stock.baseline : (stock.defaultBaseline||500);
      if (stock.frozen) { stock.price = base; return; }
      const mag = 0.01 + Math.random()*0.02; // 1–3%
      const sign = Math.random() < 0.5 ? -1 : 1;
      const next = base * (1 + sign*mag);
      // Ensure price does not go below 1
      stock.price = Math.max(1, Math.round(next * 100) / 100);
    }

    /***** Auth & Roles *****/
    onAuthStateChanged(auth, async (user)=>{
      if(!user){ showLogin(); return; }
      me = user;

      // role by UID first; fallback by email
      let myRoleDoc = await getDoc(doc(db,"artifacts",APP_ID,"public","data","roles", user.uid));
      if (myRoleDoc.exists()){
        myRole = myRoleDoc.data().role;
      } else {
        const rolesCol = collection(db,"artifacts",APP_ID,"public","data","roles");
        const qEmail = query(rolesCol, where("email","==", user.email));
        const snap = await getDocs(qEmail);
        myRole = (!snap.empty) ? (snap.docs[0].data().role) : null;
      }
      if(!myRole){ showLogin("Role not found. Create /roles/<UID> with {email, role}."); return; }

      roleHeader.textContent = `Welcome, ${myRole}`;

      // view toggles
      traderMetrics.classList.toggle("hidden", myRole === "admin");
      const isAdmin = myRole === "admin";
      chartEl.classList.toggle("hidden", isAdmin);
      tradeBar.classList.toggle("hidden", isAdmin);
      $("autoRow").classList.toggle("hidden", isAdmin);
      adminPortfolioView.classList.toggle("hidden", !isAdmin);
      adminControls.classList.toggle("hidden", !isAdmin);
      adminOnlyHint.classList.toggle("hidden", isAdmin);
      // Trader side panel should be visible for traders, and the "Admin Only visible for admins" hint hidden for them
      traderSide.classList.toggle("hidden", isAdmin);


      loginSection.classList.add("hidden");
      dashboard.classList.remove("hidden");

      await bootstrapStocks();
      attachRealtime();              // baselines/frozen flags
      attachTraderDoc();             // my trader doc
      if (isAdmin) { loadRankingsLoop(); fillTraderDropdown(); }

      // Start step timer (shared for autos + price jumps)
      startTickTimer();
      // Start UI loop (updates tiles, chart sampling, metrics)
      startAnimationLoop();
    });

    function showLogin(msg){
      dashboard.classList.add("hidden");
      loginSection.classList.remove("hidden");
      if (msg) loginError.textContent = msg;
    }

    // Stable login
    loginForm.addEventListener("submit", async (e)=>{
      e.preventDefault(); // Prevent default form submission and page refresh
      loginError.textContent = ""; loginBtn.disabled = true; loginBtn.textContent = "Logging in…";
      const email = $("email").value.trim();
      const pass  = $("password").value.trim();
      try{
        await signInWithEmailAndPassword(auth, email, pass);
        // onAuthStateChanged will handle UI update
      }catch(err){
        loginError.innerHTML = `<small class="err">${err.message}</small>`;
      }finally{
        loginBtn.disabled = false; loginBtn.textContent = "Log in";
      }
    });

    logoutBtn.addEventListener("click", async ()=>{
      try{ await signOut(auth); }catch(_){}
      location.reload();
    });

    /***** Stocks *****/
    function slug(s){ return s.toLowerCase().replace(/[^a-z0-9]+/g,"_"); }

    async function bootstrapStocks(){
      SEED_STOCKS.forEach((name)=>{
        const id = slug(name);
        if (!stocks[id]) stocks[id] = { id, name, defaultBaseline: +(300 + Math.random()*900).toFixed(2), frozen:false };
      });
      const col = collection(db,"artifacts",APP_ID,"public","data","stocks");
      const snap = await getDocs(col);
      if (snap.empty){
        for(const name of SEED_STOCKS){
          const id = slug(name);
          const base = +(stocks[id]?.defaultBaseline || (300+Math.random()*900)).toFixed(2);
          try{ await setDoc(doc(col,id), { name, baseline: base, frozen:false }, { merge:true }); }catch(_){}
        }
      }
    }

    function attachRealtime(){
      const col = collection(db,"artifacts",APP_ID,"public","data","stocks");
      onSnapshot(col, (snap)=>{
        snap.forEach(d => {
          const data = d.data()||{};
          const id = d.id;
          const prev = stocks[id] || {};
          const base = Number(data.baseline);
          const baselineChanged = Number.isFinite(prev.baseline) && Number.isFinite(base) && base !== prev.baseline;
          const priceInit = baselineChanged
              ? base
              : (Number.isFinite(prev.price) ? prev.price : (Number.isFinite(base) ? base : prev.defaultBaseline));

          stocks[id] = {
            id,
            name: data.name || prev.name || id,
            baseline: Number.isFinite(base) ? base : prev.baseline,
            price: clamp(priceInit),
            defaultBaseline: prev.defaultBaseline || +(300 + Math.random()*900).toFixed(2),
            frozen: !!data.frozen
          };
        });
        renderStockTiles();
        if (selectedId && stocks[selectedId]) detailName.textContent = stocks[selectedId].name;
        updateTradeControls();
      });
    }

    function renderStockTiles(){
      stockList.innerHTML = "";
      Object.values(stocks).forEach(s => {
        const price = currentPriceFor(s);
        const tile = document.createElement("button");
        tile.className = "tile";
        tile.innerHTML = `<div class="name">${s.name}${s.frozen?' • <small style="color:#ffb3b3;font-weight:700">FROZEN</small>':''}</div>
                          <div class="price">₹ <span id="p-${s.id}">${fmt(price, false)}</span></div>`;
        tile.addEventListener("click", ()=>selectStock(s.id));
        stockList.appendChild(tile);
      });
    }

    function updateTradeControls(){
      const s = selectedId ? stocks[selectedId] : null;
      const isFrozen = !!s?.frozen;
      buyBtn.disabled = sellBtn.disabled = isFrozen || (myRole!=="trader");
      setAutoBtn.disabled = clearAutoBtn.disabled = isFrozen || (myRole!=="trader");
      tradeMsg.textContent = isFrozen ? "This stock is frozen. Trading disabled." : "";
    }

    function selectStock(id){
      selectedId = id;
      const s = stocks[id];
      detailName.textContent = s.name;
      series = [];
      lastSampleTime = 0;
      tradeMsg.textContent = "";
      adminSelected.textContent = s.name || "None";
      adminSelectedPrice.textContent = `• ₹ ${fmt(currentPriceFor(s), false)}${s.frozen?' • FROZEN':''}`;
      detailPrice.textContent = `₹ ${fmt(currentPriceFor(s), false)}${s.frozen?' • FROZEN':''}`;
      raiseBtn.disabled = lowerBtn.disabled = raise50Btn.disabled = lower50Btn.disabled = (myRole!=="admin");
      updateTradeControls();
      drawChart();
    }

    // Admin ±10% / ±50%
    raiseBtn?.addEventListener("click", ()=> adjustSelected( 0.10));
    lowerBtn?.addEventListener("click", ()=> adjustSelected(-0.10));
    raise50Btn?.addEventListener("click", ()=> adjustSelected( 0.50));
    lower50Btn?.addEventListener("click", ()=> adjustSelected(-0.50));

    async function adjustSelected(delta){
      if(!selectedId || myRole!=="admin") return;
      const s = stocks[selectedId];
      const ref = doc(db,"artifacts",APP_ID,"public","data","stocks", selectedId);
      const base = Number.isFinite(s.baseline) ? s.baseline : (s.defaultBaseline||500);
      const newBase = +(base * (1+delta)).toFixed(2);

      // Optimistic UI
      s.baseline = newBase; s.price = newBase;
      stocks[selectedId] = s;
      adminSelectedPrice.textContent = `• ₹ ${fmt(newBase, false)}${s.frozen?' • FROZEN':''}`;
      detailPrice.textContent = `₹ ${fmt(newBase, false)}${s.frozen?' • FROZEN':''}`;
      renderStockTiles();

      // Write baseline
      try{ await updateDoc(ref, { baseline:newBase }); }
      catch(err){ try{ await setDoc(ref, { name: s.name || selectedId, baseline: newBase }, { merge: true }); }catch(_){ } }
    }

    /***** Freeze / Unfreeze *****/
    freezeBtn?.addEventListener("click", async ()=>{
      if(!selectedId || myRole!=="admin") return;
      freezeMsg.textContent = "";
      const s = stocks[selectedId];
      const ref = doc(db,"artifacts",APP_ID,"public","data","stocks", selectedId);
      try{
        await setDoc(ref, { name: s.name || selectedId, frozen: true }, { merge: true });
        s.frozen = true; stocks[selectedId] = s;
        freezeMsg.textContent = "Selected stock frozen.";
        updateTradeControls(); renderStockTiles();
      }catch(e){ freezeMsg.textContent = "Could not freeze stock."; }
    });

    unfreezeBtn?.addEventListener("click", async ()=>{
      if(!selectedId || myRole!=="admin") return;
      freezeMsg.textContent = "";
      const s = stocks[selectedId];
      const ref = doc(db,"artifacts",APP_ID,"public","data","stocks", selectedId);
      try{
        await setDoc(ref, { name: s.name || selectedId, frozen: false }, { merge: true });
        s.frozen = false; stocks[selectedId] = s;
        freezeMsg.textContent = "Selected stock unfrozen.";
        updateTradeControls(); renderStockTiles();
      }catch(e){ freezeMsg.textContent = "Could not unfreeze stock."; }
    });
    /***** Trader doc + Auto-sell (stop-loss: price <= target) *****/
    function traderRef(uid){ return doc(db,"artifacts",APP_ID,"public","data","traders", uid); }

    function updateTraderMetrics(){
      if (!myTrader) return;
      const cash = +myTrader.cash || 0;
      const invested = Object.entries(myTrader.portfolio || {}).reduce((sum,[sid,pos])=>{
        const st=stocks[sid];
        if(st) sum += (pos.quantity||0)*currentPriceFor(st);
        return sum;
      },0);
      const initial = +myTrader.initialCash || 0;
      const pl = (cash + invested) - initial;
      const plPct = initial ? (pl/initial*100) : 0;

      workingCapEl.textContent = fmt(cash);
      investedCapEl.textContent = fmt(invested);
      profitLossEl.textContent = `${fmt(plPct, false)}%`;
      profitLossEl.style.color = plPct >= 0 ? 'var(--good)' : 'var(--bad)';

      // My Portfolio table
      traderPfSummary.textContent = `Cash: ${fmt(cash)} • Invested: ${fmt(invested)} • P/L: ${fmt(plPct, false)}%`;
      traderPfTable.innerHTML = "";
      let hasHoldings = false;
      for(const sid in myTrader.portfolio){
        const pos = myTrader.portfolio[sid];
        if (pos.quantity > 0){
          hasHoldings = true;
          const s = stocks[sid];
          const currentVal = (pos.quantity||0)*currentPriceFor(s);
          const row = `<tr>
            <td>${s.name}</td>
            <td>${pos.quantity}</td>
            <td>₹${fmt(s.price, false)}</td>
            <td>₹${fmt(currentVal, false)}</td>
          </tr>`;
          traderPfTable.insertAdjacentHTML("beforeend", row);
        }
      }
      if (!hasHoldings) {
        traderPfTable.innerHTML = '<tr><td colspan="4" class="muted" style="text-align:center">No current holdings.</td></tr>';
      }
    }

    // Attach to my trader doc
    function attachTraderDoc(){
      if (!me) return;
      onSnapshot(traderRef(me.uid), (snap)=>{
        myTrader = snap.data() || { uid:me.uid, email:me.email, cash:0, initialCash:0, portfolio:{}, autos:{} };
        if (!myTrader.initialCash) myTrader.initialCash = myTrader.cash; // Set initial cash if not present
        updateTraderMetrics();
        updateAutoSellUI();
      });
    }

    async function recordTrade(stockId, quantity, price, type, traderUid = me.uid) {
        const historyCol = collection(db, "artifacts", APP_ID, "public", "data", "history");
        await setDoc(doc(historyCol), {
            traderId: traderUid,
            stockId: stockId,
            quantity: quantity,
            price: price,
            type: type, // "buy" or "sell"
            timestamp: Date.now()
        });
    }

    async function executeTrade(stockId, quantity, isBuy){
      if (!me || !myTrader || !selectedId || !stocks[selectedId] || stocks[selectedId].frozen) return;
      if (myRole !== "trader") { tradeMsg.textContent = "Only traders can trade."; return; }

      const stockPrice = currentPriceFor(stocks[stockId]);
      const cost = stockPrice * quantity;

      tradeMsg.textContent = "";

      try {
        await runTransaction(db, async (transaction) => {
          const traderDoc = await transaction.get(traderRef(me.uid));
          const currentTrader = traderDoc.data();

          if (!currentTrader) {
            throw "Trader data not found.";
          }

          let cash = currentTrader.cash || 0;
          const portfolio = currentTrader.portfolio || {};
          const currentHoldings = portfolio[stockId]?.quantity || 0;

          if (isBuy) {
            if (cash < cost) {
              throw `Not enough cash. Need ${fmt(cost)}, have ${fmt(cash)}.`;
            }
            cash -= cost;
            portfolio[stockId] = { quantity: currentHoldings + quantity, avgPrice: stockPrice }; // Simplified avgPrice for now
            tradeMsg.textContent = `Bought ${quantity} shares of ${stocks[stockId].name} for ${fmt(cost)}.`;
            await recordTrade(stockId, quantity, stockPrice, 'buy');
          } else { // Sell
            if (currentHoldings < quantity) {
              throw `Not enough shares to sell. Have ${currentHoldings}.`;
            }
            cash += cost;
            portfolio[stockId].quantity = currentHoldings - quantity;
            if (portfolio[stockId].quantity === 0) {
              delete portfolio[stockId];
            }
            tradeMsg.textContent = `Sold ${quantity} shares of ${stocks[stockId].name} for ${fmt(cost)}.`;
            await recordTrade(stockId, quantity, stockPrice, 'sell');
          }

          transaction.update(traderRef(me.uid), { cash, portfolio });
        });
      } catch (e) {
        tradeMsg.innerHTML = `<small class="err">${e?.message || e}</small>`;
      }
    }

    buyBtn.addEventListener("click", () => {
      const qty = parseInt(qtyEl.value);
      if (qty > 0 && selectedId) executeTrade(selectedId, qty, true);
    });

    sellBtn.addEventListener("click", () => {
      const qty = parseInt(qtyEl.value);
      if (qty > 0 && selectedId) executeTrade(selectedId, qty, false);
    });

    // Auto-sell logic
    function updateAutoSellUI() {
      if (!myTrader || !selectedId) {
        autoPrice.value = "";
        autoQty.value = "";
        clearAutoBtn.disabled = true;
        autoMsg.textContent = "Select a stock to set auto-sell.";
        return;
      }
      const autoSell = myTrader.autos?.[selectedId];
      if (autoSell) {
        autoPrice.value = autoSell.price;
        autoQty.value = autoSell.quantity;
        clearAutoBtn.disabled = false;
        autoMsg.textContent = `Auto-sell set: ${autoSell.quantity} shares if price drops to ₹${fmt(autoSell.price, false)}.`;
      } else {
        autoPrice.value = "";
        autoQty.value = "";
        clearAutoBtn.disabled = true;
        autoMsg.textContent = "";
      }
    }

    setAutoBtn.addEventListener("click", async () => {
      if (!me || !myTrader || !selectedId || stocks[selectedId]?.frozen) return;
      if (myRole !== "trader") { autoMsg.textContent = "Only traders can set auto-sells."; return; }

      const price = parseFloat(autoPrice.value);
      const quantity = parseInt(autoQty.value);

      if (isNaN(price) || price <= 0 || isNaN(quantity) || quantity <= 0) {
        autoMsg.innerHTML = '<small class="err">Please enter valid price and quantity.</small>';
        return;
      }
      if ((myTrader.portfolio?.[selectedId]?.quantity || 0) < quantity) {
        autoMsg.innerHTML = `<small class="err">You only have ${myTrader.portfolio?.[selectedId]?.quantity || 0} shares.</small>`;
        return;
      }

      const autoUpdate = { ...myTrader.autos, [selectedId]: { price, quantity, stockName: stocks[selectedId].name } };
      try {
        await updateDoc(traderRef(me.uid), { autos: autoUpdate });
        autoMsg.textContent = `Auto-sell set for ${quantity} shares of ${stocks[selectedId].name} at ₹${fmt(price, false)}.`;
      } catch (e) {
        autoMsg.innerHTML = `<small class="err">Error setting auto-sell: ${e.message}</small>`;
      }
    });

    clearAutoBtn.addEventListener("click", async () => {
      if (!me || !myTrader || !selectedId) return;
      if (myRole !== "trader") return;

      const autoUpdate = { ...myTrader.autos };
      delete autoUpdate[selectedId];

      try {
        await updateDoc(traderRef(me.uid), { autos: autoUpdate });
        autoMsg.textContent = "Auto-sell cleared for selected stock.";
      } catch (e) {
        autoMsg.innerHTML = `<small class="err">Error clearing auto-sell: ${e.message}</small>`;
      }
    });

    async function processAutoSells() {
      if (!me || myRole !== "trader" || !myTrader.autos) return;

      for (const stockId in myTrader.autos) {
        const autoSell = myTrader.autos[stockId];
        const stock = stocks[stockId];
        if (!stock || stock.frozen) continue;

        if (currentPriceFor(stock) <= autoSell.price) {
          // Check if we actually have enough shares to sell
          const availableQty = myTrader.portfolio?.[stockId]?.quantity || 0;
          const qtyToSell = Math.min(autoSell.quantity, availableQty);

          if (qtyToSell > 0) {
            // Execute the sell
            await executeTrade(stockId, qtyToSell, false); // false for sell
            // Remove or adjust the auto-sell after execution
            const newAutos = { ...myTrader.autos };
            if (autoSell.quantity <= availableQty) { // Sold all requested auto-sell quantity
              delete newAutos[stockId];
              autoMsg.textContent = `Auto-sold ${qtyToSell} shares of ${stock.name} at ₹${fmt(stock.price, false)}. Auto-sell cleared.`;
            } else { // Sold part of auto-sell quantity
              newAutos[stockId].quantity -= qtyToSell;
              autoMsg.textContent = `Auto-sold ${qtyToSell} shares of ${stock.name} at ₹${fmt(stock.price, false)}. Remaining auto-sell: ${newAutos[stockId].quantity}.`;
            }
            await updateDoc(traderRef(me.uid), { autos: newAutos });
          }
        }
      }
    }
    /***** Admin controls *****/
    applyFundsBtn.addEventListener("click", async ()=>{
      if (myRole !== "admin") return;
      const amount = parseFloat(allFunds.value);
      if (isNaN(amount) || amount < 0) {
        fundsMsg.innerHTML = '<small class="err">Enter a valid amount.</small>';
        return;
      }
      fundsMsg.textContent = ""; applyFundsBtn.disabled = true;

      try {
        const tradersCol = collection(db,"artifacts",APP_ID,"public","data","traders");
        const snap = await getDocs(tradersCol);
        const updates = snap.docs.map(d => updateDoc(d.ref, { cash: amount, initialCash: amount }));
        await Promise.all(updates);
        fundsMsg.textContent = "All traders' funds updated!";
      } catch (e) {
        fundsMsg.innerHTML = `<small class="err">Error updating funds: ${e.message}</small>`;
      } finally {
        applyFundsBtn.disabled = false;
      }
    });

    const resetBtn = $("resetBtn");
    resetBtn.addEventListener("click", async () => {
      if (!confirm("Are you sure you want to HARD RESET ALL TRADERS AND STOCKS? This action cannot be undone.")) return;
      if (myRole !== "admin") return;

      resetBtn.disabled = true;
      resetBtn.textContent = "Resetting...";

      try {
        // 1. Delete all trader data
        const tradersCol = collection(db, "artifacts", APP_ID, "public", "data", "traders");
        const traderDocs = await getDocs(tradersCol);
        const deleteTraderPromises = traderDocs.docs.map(d => deleteDoc(d.ref));
        await Promise.all(deleteTraderPromises);

        // 2. Reset stocks to initial baselines (or delete and re-add)
        const stocksCol = collection(db, "artifacts", APP_ID, "public", "data", "stocks");
        const stockDocs = await getDocs(stocksCol);
        const resetStockPromises = stockDocs.docs.map(async (d) => {
          const stockData = d.data();
          const defaultBaseline = SEED_STOCKS.find(name => slug(name) === d.id)?.defaultBaseline || (300 + Math.random() * 900);
          return updateDoc(d.ref, { baseline: defaultBaseline, frozen: false });
        });
        await Promise.all(resetStockPromises);

        // 3. Clear trade history (optional, but good for a hard reset)
        const historyCol = collection(db, "artifacts", APP_ID, "public", "data", "history");
        const historyDocs = await getDocs(historyCol);
        const deleteHistoryPromises = historyDocs.docs.map(d => deleteDoc(d.ref));
        await Promise.all(deleteHistoryPromises);

        alert("Hard reset complete! All traders and stocks have been reset.");
        location.reload(); // Reload to reflect changes
      } catch (e) {
        alert(`Error during hard reset: ${e.message}`);
      } finally {
        resetBtn.disabled = false;
        resetBtn.textContent = "⚠️ Hard RESET (All Traders + Stocks)";
      }
    });

    // Trader Rankings
    function loadRankingsLoop(){
      if (myRole !== "admin") return;
      const tradersCol = collection(db,"artifacts",APP_ID,"public","data","traders");
      onSnapshot(tradersCol, (snap)=>{
        const rankings = [];
        snap.forEach(d => {
          const trader = d.data();
          const cash = +trader.cash || 0;
          const invested = Object.entries(trader.portfolio || {}).reduce((sum,[sid,pos])=>{
            const st = stocks[sid];
            if(st) sum += (pos.quantity||0)*currentPriceFor(st);
            return sum;
          },0);
          const initial = +trader.initialCash || 0;
          const totalEquity = cash + invested;
          const pl = totalEquity - initial;
          const plPct = initial ? (pl/initial*100) : 0;
          rankings.push({ ...trader, totalEquity, pl, plPct });
        });
        rankings.sort((a,b)=>b.totalEquity - a.totalEquity); // Sort by total equity

        rankTable.innerHTML = "";
        rankings.forEach((r,idx)=>{
          const row = `<tr>
            <td>${idx+1}</td>
            <td>${r.email?.split('@')[0]}</td>
            <td>${fmt(r.totalEquity)}</td>
            <td style="color:${r.plPct >= 0 ? 'var(--good)' : 'var(--bad)'}">${fmt(r.plPct, false)}%</td>
          </tr>`;
          rankTable.insertAdjacentHTML("beforeend", row);
        });
      });
    }

    // Admin Trader Portfolio Viewer
    let allTraders = [];
    async function fillTraderDropdown(){
      if (myRole !== "admin") return;
      traderSelect.innerHTML = '<option value="">Select a Trader</option>';
      const tradersCol = collection(db,"artifacts",APP_ID,"public","data","traders");
      const snap = await getDocs(tradersCol);
      allTraders = snap.docs.map(d => d.data());
      allTraders.forEach(trader => {
        const option = document.createElement("option");
        option.value = trader.uid;
        option.textContent = trader.email;
        traderSelect.appendChild(option);
      });
    }

    traderSelect.addEventListener("change", ()=>{
      const selectedTraderUid = traderSelect.value;
      if (!selectedTraderUid) {
        portfolioWrap.style.display = 'none';
        pfTable.innerHTML = "";
        pfSummary.textContent = "";
        historyTable.innerHTML = "";
        return;
      }
      portfolioWrap.style.display = 'block';
      const selectedTrader = allTraders.find(t => t.uid === selectedTraderUid);
      if (selectedTrader) {
        pfTitle.textContent = `${selectedTrader.email}'s Portfolio`;
        renderAdminPortfolio(selectedTrader);
        loadTradeHistory(selectedTraderUid); // Load history for selected trader
      }
    });

    function renderAdminPortfolio(trader){
      pfTable.innerHTML = "";
      let totalInvested = 0;
      let hasHoldings = false;
      for(const sid in trader.portfolio){
        const pos = trader.portfolio[sid];
        if (pos.quantity > 0){
          hasHoldings = true;
          const s = stocks[sid];
          const currentVal = (pos.quantity||0)*currentPriceFor(s);
          totalInvested += currentVal;
          const row = `<tr>
            <td>${s.name}</td>
            <td>${pos.quantity}</td>
            <td>₹${fmt(s.price, false)}</td>
            <td>₹${fmt(currentVal, false)}</td>
          </tr>`;
          pfTable.insertAdjacentHTML("beforeend", row);
        }
      }
      if (!hasHoldings) {
        pfTable.innerHTML = '<tr><td colspan="4" class="muted" style="text-align:center">No current holdings.</td></tr>';
      }

      const initial = +trader.initialCash || 0;
      const currentCash = +trader.cash || 0;
      const totalEquity = currentCash + totalInvested;
      const pl = totalEquity - initial;
      const plPct = initial ? (pl/initial*100) : 0;
      pfSummary.innerHTML = `Cash: ${fmt(currentCash)} • Invested: ${fmt(totalInvested)} • Total Equity: ${fmt(totalEquity)} • P/L: <span style="color:${plPct >= 0 ? 'var(--good)' : 'var(--bad)'}">${fmt(plPct, false)}%</span>`;
    }

    // Admin: Load Trade History
    function loadTradeHistory(traderUid){
      historyTable.innerHTML = "";
      const historyCol = collection(db, "artifacts", APP_ID, "public", "data", "history");
      const q = query(historyCol, where("traderId", "==", traderUid));

      onSnapshot(q, (snapshot) => {
        historyTable.innerHTML = ""; // Clear existing entries
        if (snapshot.empty) {
          historyTable.innerHTML = '<tr><td colspan="6" class="muted" style="text-align:center">No trade history.</td></tr>';
          return;
        }

        const trades = [];
        snapshot.forEach(doc => {
          trades.push(doc.data());
        });

        trades.sort((a, b) => b.timestamp - a.timestamp); // Sort by newest first

        trades.forEach(trade => {
          const stockName = stocks[trade.stockId]?.name || trade.stockId;
          const actionClass = trade.type === 'buy' ? 'var(--good)' : 'var(--bad)';
          const date = new Date(trade.timestamp).toLocaleString();
          const row = `<tr>
            <td>${date}</td>
            <td style="color:${actionClass}">${trade.type.toUpperCase()}</td>
            <td>${stockName}</td>
            <td>${trade.quantity}</td>
            <td>₹${fmt(trade.price, false)}</td>
            <td>₹${fmt(trade.quantity * trade.price, false)}</td>
          </tr>`;
          historyTable.insertAdjacentHTML("beforeend", row);
        });
      });
    }

    /***** Charting (Canvas) *****/
    const ctx = chartEl.getContext("2d");
    function drawChart(){
      if (!selectedId || !stocks[selectedId]) return;
      const s = stocks[selectedId];

      ctx.clearRect(0,0, chartEl.width, chartEl.height);
      ctx.font = "12px system-ui";
      ctx.fillStyle = "var(--muted)";
      ctx.strokeStyle = "var(--accent)";
      ctx.lineWidth = 2;

      const padding = 20;
      const chartWidth = chartEl.width - padding * 2;
      const chartHeight = chartEl.height - padding * 2;

      // Find min/max price for scaling
      const prices = series.map(d=>d.price);
      let minPrice = Math.min(...prices, currentPriceFor(s));
      let maxPrice = Math.max(...prices, currentPriceFor(s));
      if (prices.length === 0) { // If no series data, just use current price
        minPrice = currentPriceFor(s) * 0.9;
        maxPrice = currentPriceFor(s) * 1.1;
      } else if (minPrice === maxPrice) { // Prevent division by zero if all prices are same
        minPrice *= 0.9;
        maxPrice *= 1.1;
      }

      const priceRange = maxPrice - minPrice;
      const xStep = chartWidth / (series.length > 1 ? series.length - 1 : 1);

      ctx.beginPath();
      for (let i = 0; i < series.length; i++) {
        const x = padding + i * xStep;
        const y = padding + chartHeight - ((series[i].price - minPrice) / priceRange) * chartHeight;
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // Draw current price dot
      const currentX = padding + chartWidth; // Always at the right edge
      const currentY = padding + chartHeight - ((currentPriceFor(s) - minPrice) / priceRange) * chartHeight;
      ctx.beginPath();
      ctx.arc(currentX, currentY, 4, 0, Math.PI * 2);
      ctx.fillStyle = "var(--accent)";
      ctx.fill();

      // Price labels
      ctx.fillStyle = "var(--muted)";
      ctx.fillText(fmt(maxPrice, false), padding, padding - 5);
      ctx.fillText(fmt(minPrice, false), padding, chartEl.height - padding + 15);
      ctx.fillText(fmt(currentPriceFor(s), false), currentX + 10, currentY + 4);
    }
    /***** Main Loops *****/
    let animationFrameId = null;

    function startTickTimer(){
      if (lastProcessedTick !== -1) return; // Already running
      lastProcessedTick = Date.now();
      lastAutosTick = Date.now();
      setInterval(async ()=>{
        const now = Date.now();
        // Price jumps for all stocks
        Object.values(stocks).forEach(s => jumpOnce(s));

        // Process auto-sells for the current user if they are a trader
        if (myRole === "trader" && myTrader && now - lastAutosTick >= TICK_MS) {
            await processAutoSells();
            lastAutosTick = now;
        }

        lastProcessedTick = now;
      }, TICK_MS);
    }

    function startAnimationLoop(){
      if (animationFrameId !== null) return; // Already running
      function animate(){
        // Update stock tile prices
        Object.values(stocks).forEach(s => {
          const priceEl = $(`p-${s.id}`);
          if (priceEl) priceEl.textContent = fmt(currentPriceFor(s), false);
        });

        // Update selected stock detail price
        if (selectedId && stocks[selectedId]){
          const s = stocks[selectedId];
          detailPrice.textContent = `₹ ${fmt(currentPriceFor(s), false)}${s.frozen?' • FROZEN':''}`;
          adminSelectedPrice.textContent = `• ₹ ${fmt(currentPriceFor(s), false)}${s.frozen?' • FROZEN':''}`;
        }

        // Chart sampling and drawing
        const now = Date.now();
        if (selectedId && now - lastSampleTime > 1000) { // Sample every 1 second
          series.push({ price: currentPriceFor(stocks[selectedId]), time: now });
          if (series.length > 50) series.shift(); // Keep last 50 samples
          drawChart();
          lastSampleTime = now;
        } else if (!selectedId) {
          ctx.clearRect(0,0, chartEl.width, chartEl.height);
        }

        if (myRole === "trader") {
          updateTraderMetrics(); // Update trader metrics continuously
        }
        if (myRole === "admin" && traderSelect.value) {
            const selectedTrader = allTraders.find(t => t.uid === traderSelect.value);
            if(selectedTrader) renderAdminPortfolio(selectedTrader); // Update admin view if a trader is selected
        }


        animationFrameId = requestAnimationFrame(animate);
      }
      animationFrameId = requestAnimationFrame(animate);
    }

    // Stop animation loop if needed (e.g., logout or switch view)
    function stopAnimationLoop(){
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    // Initial call to attachTraderDoc if user is already logged in (e.g., after a refresh)
    // The onAuthStateChanged listener handles this, but a direct call can ensure immediate updates if session is persistent.
    if (auth.currentUser) {
        // onAuthStateChanged will be triggered automatically if a user is logged in
        // no need for manual call here
    }

  </script>
</body>
</html>
